// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  late final ffi.Pointer<ffi.Int> _zipWriteStatusLength =
      _lookup<ffi.Int>('zipWriteStatusLength');

  int get zipWriteStatusLength => _zipWriteStatusLength.value;

  set zipWriteStatusLength(int value) => _zipWriteStatusLength.value = value;

  /// Looks up the error message string corresponding to an error number.
  /// @param errnum error number
  /// @return error message string corresponding to errnum or NULL if error is not
  /// found.
  ffi.Pointer<ffi.Char> zip_strerror(
    int errnum,
  ) {
    return _zip_strerror(
      errnum,
    );
  }

  late final _zip_strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'zip_strerror');
  late final _zip_strerror =
      _zip_strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Opens zip archive with compression level using the given mode.
  ///
  /// @param zipname zip archive file name.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_open(
    ffi.Pointer<ffi.Char> zipname,
    int level,
    int mode,
  ) {
    return _zip_open(
      zipname,
      level,
      mode,
    );
  }

  late final _zip_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Char)>>('zip_open');
  late final _zip_open = _zip_openPtr.asFunction<
      ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Opens zip archive with compression level using the given mode.
  /// The function additionally returns @param errnum -
  ///
  /// @param zipname zip archive file name.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  /// @param errnum 0 on success, negative number (< 0) on error.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_openwitherror(
    ffi.Pointer<ffi.Char> zipname,
    int level,
    int mode,
    ffi.Pointer<ffi.Int> errnum,
  ) {
    return _zip_openwitherror(
      zipname,
      level,
      mode,
      errnum,
    );
  }

  late final _zip_openwitherrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Char,
              ffi.Pointer<ffi.Int>)>>('zip_openwitherror');
  late final _zip_openwitherror = _zip_openwitherrorPtr.asFunction<
      ffi.Pointer<zip_t> Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Int>)>();

  /// Closes the zip archive, releases resources - always finalize.
  ///
  /// @param zip zip archive handler.
  void zip_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_close(
      zip,
    );
  }

  late final _zip_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<zip_t>)>>(
          'zip_close');
  late final _zip_close =
      _zip_closePtr.asFunction<void Function(ffi.Pointer<zip_t>)>();

  /// Determines if the archive has a zip64 end of central directory headers.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 1 (true), 0 (false), negative number (< 0) on
  /// error.
  int zip_is64(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_is64(
      zip,
    );
  }

  late final _zip_is64Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_is64');
  late final _zip_is64 =
      _zip_is64Ptr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Opens an entry by name in the zip archive.
  ///
  /// For zip archive opened in 'w' or 'a' mode the function will append
  /// a new entry. In readonly mode the function tries to locate the entry
  /// in global dictionary.
  ///
  /// @param zip zip archive handler.
  /// @param entryname an entry name in local dictionary.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_open(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> entryname,
  ) {
    return _zip_entry_open(
      zip,
      entryname,
    );
  }

  late final _zip_entry_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_open');
  late final _zip_entry_open = _zip_entry_openPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Opens an entry by name in the zip archive.
  ///
  /// For zip archive opened in 'w' or 'a' mode the function will append
  /// a new entry. In readonly mode the function tries to locate the entry
  /// in global dictionary (case sensitive).
  ///
  /// @param zip zip archive handler.
  /// @param entryname an entry name in local dictionary (case sensitive).
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_opencasesensitive(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> entryname,
  ) {
    return _zip_entry_opencasesensitive(
      zip,
      entryname,
    );
  }

  late final _zip_entry_opencasesensitivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Char>)>>('zip_entry_opencasesensitive');
  late final _zip_entry_opencasesensitive = _zip_entry_opencasesensitivePtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Opens a new entry by index in the zip archive.
  ///
  /// This function is only valid if zip archive was opened in 'r' (readonly) mode.
  ///
  /// @param zip zip archive handler.
  /// @param index index in local dictionary.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_openbyindex(
    ffi.Pointer<zip_t> zip,
    int index,
  ) {
    return _zip_entry_openbyindex(
      zip,
      index,
    );
  }

  late final _zip_entry_openbyindexPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>, ffi.Size)>>(
      'zip_entry_openbyindex');
  late final _zip_entry_openbyindex = _zip_entry_openbyindexPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, int)>();

  /// Closes a zip entry, flushes buffer and releases resources.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_close(
      zip,
    );
  }

  late final _zip_entry_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_close');
  late final _zip_entry_close =
      _zip_entry_closePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns a local name of the current zip entry.
  ///
  /// The main difference between user's entry name and local entry name
  /// is optional relative path.
  /// Following .ZIP File Format Specification - the path stored MUST not contain
  /// a drive or device letter, or a leading slash.
  /// All slashes MUST be forward slashes '/' as opposed to backwards slashes '\'
  /// for compatibility with Amiga and UNIX file systems etc.
  ///
  /// @param zip: zip archive handler.
  ///
  /// @return the pointer to the current zip entry name, or NULL on error.
  ffi.Pointer<ffi.Char> zip_entry_name(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_name(
      zip,
    );
  }

  late final _zip_entry_namePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_name');
  late final _zip_entry_name = _zip_entry_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zip_t>)>();

  /// Returns an index of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the index on success, negative number (< 0) on error.
  int zip_entry_index(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_index(
      zip,
    );
  }

  late final _zip_entry_indexPtr =
      _lookup<ffi.NativeFunction<ssize_t Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_index');
  late final _zip_entry_index =
      _zip_entry_indexPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Determines if the current zip entry is a directory entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 1 (true), 0 (false), negative number (< 0) on
  /// error.
  int zip_entry_isdir(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_isdir(
      zip,
    );
  }

  late final _zip_entry_isdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_isdir');
  late final _zip_entry_isdir =
      _zip_entry_isdirPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the uncompressed size of the current zip entry.
  /// Alias for zip_entry_uncomp_size (for backward compatibility).
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the uncompressed size in bytes.
  int zip_entry_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_size(
      zip,
    );
  }

  late final _zip_entry_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>('zip_entry_size');
  late final _zip_entry_size =
      _zip_entry_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the uncompressed size of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the uncompressed size in bytes.
  int zip_entry_uncomp_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_uncomp_size(
      zip,
    );
  }

  late final _zip_entry_uncomp_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_uncomp_size');
  late final _zip_entry_uncomp_size =
      _zip_entry_uncomp_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the compressed size of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the compressed size in bytes.
  int zip_entry_comp_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_comp_size(
      zip,
    );
  }

  late final _zip_entry_comp_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_comp_size');
  late final _zip_entry_comp_size =
      _zip_entry_comp_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns CRC-32 checksum of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the CRC-32 checksum.
  int zip_entry_crc32(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_crc32(
      zip,
    );
  }

  late final _zip_entry_crc32Ptr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_crc32');
  late final _zip_entry_crc32 =
      _zip_entry_crc32Ptr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns byte offset of the current zip entry
  /// in the archive's central directory.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the offset in bytes.
  int zip_entry_dir_offset(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_dir_offset(
      zip,
    );
  }

  late final _zip_entry_dir_offsetPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_dir_offset');
  late final _zip_entry_dir_offset =
      _zip_entry_dir_offsetPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the current zip entry's local header file offset in bytes.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the entry's local header file offset in bytes.
  int zip_entry_header_offset(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_header_offset(
      zip,
    );
  }

  late final _zip_entry_header_offsetPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_header_offset');
  late final _zip_entry_header_offset = _zip_entry_header_offsetPtr
      .asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Compresses an input buffer for the current zip entry.
  ///
  /// @param zip zip archive handler.
  /// @param buf input buffer.
  /// @param bufsize input buffer size (in bytes).
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_write(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Void> buf,
    int bufsize,
  ) {
    return _zip_entry_write(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('zip_entry_write');
  late final _zip_entry_write = _zip_entry_writePtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>, int)>();

  /// Compresses a file for the current zip entry.
  ///
  /// @param zip zip archive handler.
  /// @param filename input file.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_fwrite(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _zip_entry_fwrite(
      zip,
      filename,
    );
  }

  late final _zip_entry_fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_fwrite');
  late final _zip_entry_fwrite = _zip_entry_fwritePtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  int zip_entry_thread_write(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> entryname,
    ffi.Pointer<ffi.Void> buf,
    int bufsize,
  ) {
    return _zip_entry_thread_write(
      zip,
      entryname,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_thread_writePtr = _lookup<
      ffi.NativeFunction<
          ZipThreadWriteHandler Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('zip_entry_thread_write');
  late final _zip_entry_thread_write = _zip_entry_thread_writePtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>, int)>();

  int zip_entry_thread_write_files(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entryname,
    ffi.Pointer<ffi.Pointer<ffi.Char>> filenames,
    int count,
  ) {
    return _zip_entry_thread_write_files(
      zip,
      entryname,
      filenames,
      count,
    );
  }

  late final _zip_entry_thread_write_filesPtr = _lookup<
      ffi.NativeFunction<
          ZipThreadWriteHandler Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('zip_entry_thread_write_files');
  late final _zip_entry_thread_write_files =
      _zip_entry_thread_write_filesPtr.asFunction<
          int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int zip_thread_write_status(
    ffi.Pointer<zip_t> zip,
    int handler,
  ) {
    return _zip_thread_write_status(
      zip,
      handler,
    );
  }

  late final _zip_thread_write_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<zip_t>,
              ZipThreadWriteHandler)>>('zip_thread_write_status');
  late final _zip_thread_write_status = _zip_thread_write_statusPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, int)>();

  /// Extracts the current zip entry into output buffer.
  ///
  /// The function allocates sufficient memory for a output buffer.
  ///
  /// @param zip zip archive handler.
  /// @param buf output buffer.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @note remember to release memory allocated for a output buffer.
  /// for large entries, please take a look at zip_entry_extract function.
  ///
  /// @return the return code - the number of bytes actually read on success.
  /// Otherwise a negative number (< 0) on error.
  int zip_entry_read(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buf,
    ffi.Pointer<ffi.Size> bufsize,
  ) {
    return _zip_entry_read(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('zip_entry_read');
  late final _zip_entry_read = _zip_entry_readPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Size>)>();

  /// Extracts the current zip entry into a memory buffer using no memory
  /// allocation.
  ///
  /// @param zip zip archive handler.
  /// @param buf preallocated output buffer.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @note ensure supplied output buffer is large enough.
  /// zip_entry_size function (returns uncompressed size for the current
  /// entry) can be handy to estimate how big buffer is needed.
  /// For large entries, please take a look at zip_entry_extract function.
  ///
  /// @return the return code - the number of bytes actually read on success.
  /// Otherwise a negative number (< 0) on error (e.g. bufsize is not large
  /// enough).
  int zip_entry_noallocread(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Void> buf,
    int bufsize,
  ) {
    return _zip_entry_noallocread(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_noallocreadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('zip_entry_noallocread');
  late final _zip_entry_noallocread = _zip_entry_noallocreadPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>, int)>();

  /// Extracts the current zip entry into output file.
  ///
  /// @param zip zip archive handler.
  /// @param filename output file.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_fread(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _zip_entry_fread(
      zip,
      filename,
    );
  }

  late final _zip_entry_freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_fread');
  late final _zip_entry_fread = _zip_entry_freadPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Extracts the current zip entry using a callback function (on_extract).
  ///
  /// @param zip zip archive handler.
  /// @param on_extract callback function.
  /// @param arg opaque pointer (optional argument, which you can pass to the
  /// on_extract callback)
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_extract(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Size Function(ffi.Pointer<ffi.Void> arg, ffi.Uint64 offset,
                    ffi.Pointer<ffi.Void> data, ffi.Size size)>>
        on_extract,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_entry_extract(
      zip,
      on_extract,
      arg,
    );
  }

  late final _zip_entry_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Size Function(
                          ffi.Pointer<ffi.Void> arg,
                          ffi.Uint64 offset,
                          ffi.Pointer<ffi.Void> data,
                          ffi.Size size)>>,
              ffi.Pointer<ffi.Void>)>>('zip_entry_extract');
  late final _zip_entry_extract = _zip_entry_extractPtr.asFunction<
      int Function(
          ffi.Pointer<zip_t>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Size Function(
                      ffi.Pointer<ffi.Void> arg,
                      ffi.Uint64 offset,
                      ffi.Pointer<ffi.Void> data,
                      ffi.Size size)>>,
          ffi.Pointer<ffi.Void>)>();

  /// Returns the number of all entries (files and directories) in the zip archive.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - the number of entries on success, negative number
  /// (< 0) on error.
  int zip_entries_total(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entries_total(
      zip,
    );
  }

  late final _zip_entries_totalPtr =
      _lookup<ffi.NativeFunction<ssize_t Function(ffi.Pointer<zip_t>)>>(
          'zip_entries_total');
  late final _zip_entries_total =
      _zip_entries_totalPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Deletes zip archive entries.
  ///
  /// @param zip zip archive handler.
  /// @param entries array of zip archive entries to be deleted.
  /// @param len the number of entries to be deleted.
  /// @return the number of deleted entries, or negative number (< 0) on error.
  int zip_entries_delete(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entries,
    int len,
  ) {
    return _zip_entries_delete(
      zip,
      entries,
      len,
    );
  }

  late final _zip_entries_deletePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('zip_entries_delete');
  late final _zip_entries_delete = _zip_entries_deletePtr.asFunction<
      int Function(
          ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Deletes zip archive entries.
  ///
  /// @param zip zip archive handler.
  /// @param entries array of zip archive entries indices to be deleted.
  /// @param len the number of entries to be deleted.
  /// @return the number of deleted entries, or negative number (< 0) on error.
  int zip_entries_deletebyindex(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Size> entries,
    int len,
  ) {
    return _zip_entries_deletebyindex(
      zip,
      entries,
      len,
    );
  }

  late final _zip_entries_deletebyindexPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Size>,
              ffi.Size)>>('zip_entries_deletebyindex');
  late final _zip_entries_deletebyindex =
      _zip_entries_deletebyindexPtr.asFunction<
          int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Size>, int)>();

  /// Extracts a zip archive stream into directory.
  ///
  /// If on_extract is not NULL, the callback will be called after
  /// successfully extracted each zip entry.
  /// Returning a negative value from the callback will cause abort and return an
  /// error. The last argument (void *arg) is optional, which you can use to pass
  /// data to the on_extract callback.
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.
  /// @param dir output directory.
  /// @param on_extract on extract callback.
  /// @param arg opaque pointer.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_stream_extract(
    ffi.Pointer<ffi.Char> stream,
    int size,
    ffi.Pointer<ffi.Char> dir,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Char> filename, ffi.Pointer<ffi.Void> arg)>>
        on_extract,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_stream_extract(
      stream,
      size,
      dir,
      on_extract,
      arg,
    );
  }

  late final _zip_stream_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                          ffi.Pointer<ffi.Void> arg)>>,
              ffi.Pointer<ffi.Void>)>>('zip_stream_extract');
  late final _zip_stream_extract = _zip_stream_extractPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                      ffi.Pointer<ffi.Void> arg)>>,
          ffi.Pointer<ffi.Void>)>();

  /// Opens zip archive stream into memory.
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_stream_open(
    ffi.Pointer<ffi.Char> stream,
    int size,
    int level,
    int mode,
  ) {
    return _zip_stream_open(
      stream,
      size,
      level,
      mode,
    );
  }

  late final _zip_stream_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Char)>>('zip_stream_open');
  late final _zip_stream_open = _zip_stream_openPtr.asFunction<
      ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Opens zip archive stream into memory.
  /// The function additionally returns @param errnum -
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.*
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  /// @param errnum 0 on success, negative number (< 0) on error.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_stream_openwitherror(
    ffi.Pointer<ffi.Char> stream,
    int size,
    int level,
    int mode,
    ffi.Pointer<ffi.Int> errnum,
  ) {
    return _zip_stream_openwitherror(
      stream,
      size,
      level,
      mode,
      errnum,
    );
  }

  late final _zip_stream_openwitherrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Char, ffi.Pointer<ffi.Int>)>>('zip_stream_openwitherror');
  late final _zip_stream_openwitherror =
      _zip_stream_openwitherrorPtr.asFunction<
          ffi.Pointer<zip_t> Function(
              ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Int>)>();

  /// Copy zip archive stream output buffer.
  ///
  /// @param zip zip archive handler.
  /// @param buf output buffer. User should free buf.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @return copy size
  int zip_stream_copy(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buf,
    ffi.Pointer<ffi.Size> bufsize,
  ) {
    return _zip_stream_copy(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_stream_copyPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('zip_stream_copy');
  late final _zip_stream_copy = _zip_stream_copyPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Size>)>();

  /// Close zip archive releases resources.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return
  void zip_stream_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_stream_close(
      zip,
    );
  }

  late final _zip_stream_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<zip_t>)>>(
          'zip_stream_close');
  late final _zip_stream_close =
      _zip_stream_closePtr.asFunction<void Function(ffi.Pointer<zip_t>)>();

  /// Creates a new archive and puts files into a single zip archive.
  ///
  /// @param zipname zip archive file.
  /// @param filenames input files.
  /// @param len: number of input files.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_create(
    ffi.Pointer<ffi.Char> zipname,
    ffi.Pointer<ffi.Pointer<ffi.Char>> filenames,
    int len,
  ) {
    return _zip_create(
      zipname,
      filenames,
      len,
    );
  }

  late final _zip_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Size)>>('zip_create');
  late final _zip_create = _zip_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Extracts a zip archive file into directory.
  ///
  /// If on_extract_entry is not NULL, the callback will be called after
  /// successfully extracted each zip entry.
  /// Returning a negative value from the callback will cause abort and return an
  /// error. The last argument (void *arg) is optional, which you can use to pass
  /// data to the on_extract_entry callback.
  ///
  /// @param zipname zip archive file.
  /// @param dir output directory.
  /// @param on_extract_entry on extract callback.
  /// @param arg opaque pointer.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_extract(
    ffi.Pointer<ffi.Char> zipname,
    ffi.Pointer<ffi.Char> dir,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Char> filename, ffi.Pointer<ffi.Void> arg)>>
        on_extract_entry,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_extract(
      zipname,
      dir,
      on_extract_entry,
      arg,
    );
  }

  late final _zip_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                          ffi.Pointer<ffi.Void> arg)>>,
              ffi.Pointer<ffi.Void>)>>('zip_extract');
  late final _zip_extract = _zip_extractPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                      ffi.Pointer<ffi.Void> arg)>>,
          ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.UnsignedChar> tdefl_compress_data(
    ffi.Pointer<ffi.Void> inBuf,
    int inSize,
    ffi.Pointer<ffi.Size> outSize,
    int flags,
  ) {
    return _tdefl_compress_data(
      inBuf,
      inSize,
      outSize,
      flags,
    );
  }

  late final _tdefl_compress_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Size>,
              ffi.Int)>>('tdefl_compress_data');
  late final _tdefl_compress_data = _tdefl_compress_dataPtr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Size>, int)>();

  void tdefl_free_data(
    ffi.Pointer<ffi.UnsignedChar> buf,
  ) {
    return _tdefl_free_data(
      buf,
    );
  }

  late final _tdefl_free_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>)>>(
      'tdefl_free_data');
  late final _tdefl_free_data = _tdefl_free_dataPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>)>();
}

typedef va_list = ffi.Pointer<ffi.Char>;

/// @struct zip_t
///
/// This data structure is used throughout the library to represent zip archive -
/// forward declaration.
final class zip_t extends ffi.Opaque {}

abstract class ZipWriteStatus {
  static const int ZIP_STATUS_NO_USE = 0;
  static const int ZIP_WRITE_STATUS_OK = 1;
  static const int ZIP_WRITE_STATUS_ERROR = 2;
  static const int ZIP_WRITE_STATUS_WRITING = 3;
}

typedef ssize_t = ffi.LongLong;
typedef ZipThreadWriteHandler = ffi.Int;

/// Flags for tdefl_compress_data
abstract class TDEFL_COMPRESS_FLAGS {
  static const int TDEFL_COMPRESS_WRITE_ZLIB_HEADER = 4096;
  static const int TDEFL_COMPRESS_COMPUTE_ADLER32 = 8192;
  static const int TDEFL_COMPRESS_GREEDY_PARSING_FLAG = 16384;
  static const int TDEFL_COMPRESS_NONDETERMINISTIC_PARSING_FLAG = 32768;
  static const int TDEFL_COMPRESS_RLE_MATCHES = 65536;
  static const int TDEFL_COMPRESS_FILTER_MATCHES = 131072;
  static const int TDEFL_COMPRESS_FORCE_ALL_STATIC_BLOCKS = 262144;
  static const int TDEFL_COMPRESS_FORCE_ALL_RAW_BLOCKS = 524288;
  static const int TDEFL_COMPRESS_HUFFMAN_ONLY = 0;
  static const int TDEFL_COMPRESS_DEFAULT_MAX_PROBES = 128;
  static const int TDEFL_COMPRESS_MAX_PROBES_MASK = 4095;
}

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int ZIP_DEFAULT_COMPRESSION_LEVEL = 6;

const int ZIP_ENOINIT = -1;

const int ZIP_EINVENTNAME = -2;

const int ZIP_ENOENT = -3;

const int ZIP_EINVMODE = -4;

const int ZIP_EINVLVL = -5;

const int ZIP_ENOSUP64 = -6;

const int ZIP_EMEMSET = -7;

const int ZIP_EWRTENT = -8;

const int ZIP_ETDEFLINIT = -9;

const int ZIP_EINVIDX = -10;

const int ZIP_ENOHDR = -11;

const int ZIP_ETDEFLBUF = -12;

const int ZIP_ECRTHDR = -13;

const int ZIP_EWRTHDR = -14;

const int ZIP_EWRTDIR = -15;

const int ZIP_EOPNFILE = -16;

const int ZIP_EINVENTTYPE = -17;

const int ZIP_EMEMNOALLOC = -18;

const int ZIP_ENOFILE = -19;

const int ZIP_ENOPERM = -20;

const int ZIP_EOOMEM = -21;

const int ZIP_EINVZIPNAME = -22;

const int ZIP_EMKDIR = -23;

const int ZIP_ESYMLINK = -24;

const int ZIP_ECLSZIP = -25;

const int ZIP_ECAPSIZE = -26;

const int ZIP_EFSEEK = -27;

const int ZIP_EFREAD = -28;

const int ZIP_EFWRITE = -29;

const int ZIP_ERINIT = -30;

const int ZIP_EWINIT = -31;

const int ZIP_EWRINIT = -32;
