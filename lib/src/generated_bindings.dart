// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Looks up the error message string corresponding to an error number.
  /// @param errnum error number
  /// @return error message string corresponding to errnum or NULL if error is not
  /// found.
  ffi.Pointer<ffi.Char> zip_strerror(
    int errnum,
  ) {
    return _zip_strerror(
      errnum,
    );
  }

  late final _zip_strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'zip_strerror');
  late final _zip_strerror =
      _zip_strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Opens zip archive with compression level using the given mode.
  ///
  /// @param zipname zip archive file name.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_open(
    ffi.Pointer<ffi.Char> zipname,
    int level,
    int mode,
  ) {
    return _zip_open(
      zipname,
      level,
      mode,
    );
  }

  late final _zip_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Char)>>('zip_open');
  late final _zip_open = _zip_openPtr.asFunction<
      ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Opens zip archive with compression level using the given mode.
  /// The function additionally returns @param errnum -
  ///
  /// @param zipname zip archive file name.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  /// @param errnum 0 on success, negative number (< 0) on error.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_openwitherror(
    ffi.Pointer<ffi.Char> zipname,
    int level,
    int mode,
    ffi.Pointer<ffi.Int> errnum,
  ) {
    return _zip_openwitherror(
      zipname,
      level,
      mode,
      errnum,
    );
  }

  late final _zip_openwitherrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Char,
              ffi.Pointer<ffi.Int>)>>('zip_openwitherror');
  late final _zip_openwitherror = _zip_openwitherrorPtr.asFunction<
      ffi.Pointer<zip_t> Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Int>)>();

  /// Closes the zip archive, releases resources - always finalize.
  ///
  /// @param zip zip archive handler.
  void zip_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_close(
      zip,
    );
  }

  late final _zip_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<zip_t>)>>(
          'zip_close');
  late final _zip_close =
      _zip_closePtr.asFunction<void Function(ffi.Pointer<zip_t>)>();

  /// Determines if the archive has a zip64 end of central directory headers.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 1 (true), 0 (false), negative number (< 0) on
  /// error.
  int zip_is64(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_is64(
      zip,
    );
  }

  late final _zip_is64Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_is64');
  late final _zip_is64 =
      _zip_is64Ptr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Opens an entry by name in the zip archive.
  ///
  /// For zip archive opened in 'w' or 'a' mode the function will append
  /// a new entry. In readonly mode the function tries to locate the entry
  /// in global dictionary.
  ///
  /// @param zip zip archive handler.
  /// @param entryname an entry name in local dictionary.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_open(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> entryname,
  ) {
    return _zip_entry_open(
      zip,
      entryname,
    );
  }

  late final _zip_entry_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_open');
  late final _zip_entry_open = _zip_entry_openPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Opens an entry by name in the zip archive.
  ///
  /// For zip archive opened in 'w' or 'a' mode the function will append
  /// a new entry. In readonly mode the function tries to locate the entry
  /// in global dictionary (case sensitive).
  ///
  /// @param zip zip archive handler.
  /// @param entryname an entry name in local dictionary (case sensitive).
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_opencasesensitive(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> entryname,
  ) {
    return _zip_entry_opencasesensitive(
      zip,
      entryname,
    );
  }

  late final _zip_entry_opencasesensitivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Char>)>>('zip_entry_opencasesensitive');
  late final _zip_entry_opencasesensitive = _zip_entry_opencasesensitivePtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Opens a new entry by index in the zip archive.
  ///
  /// This function is only valid if zip archive was opened in 'r' (readonly) mode.
  ///
  /// @param zip zip archive handler.
  /// @param index index in local dictionary.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_openbyindex(
    ffi.Pointer<zip_t> zip,
    int index,
  ) {
    return _zip_entry_openbyindex(
      zip,
      index,
    );
  }

  late final _zip_entry_openbyindexPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>, ffi.Size)>>(
      'zip_entry_openbyindex');
  late final _zip_entry_openbyindex = _zip_entry_openbyindexPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, int)>();

  /// Closes a zip entry, flushes buffer and releases resources.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_close(
      zip,
    );
  }

  late final _zip_entry_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_close');
  late final _zip_entry_close =
      _zip_entry_closePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns a local name of the current zip entry.
  ///
  /// The main difference between user's entry name and local entry name
  /// is optional relative path.
  /// Following .ZIP File Format Specification - the path stored MUST not contain
  /// a drive or device letter, or a leading slash.
  /// All slashes MUST be forward slashes '/' as opposed to backwards slashes '\'
  /// for compatibility with Amiga and UNIX file systems etc.
  ///
  /// @param zip: zip archive handler.
  ///
  /// @return the pointer to the current zip entry name, or NULL on error.
  ffi.Pointer<ffi.Char> zip_entry_name(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_name(
      zip,
    );
  }

  late final _zip_entry_namePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_name');
  late final _zip_entry_name = _zip_entry_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zip_t>)>();

  /// Returns an index of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the index on success, negative number (< 0) on error.
  int zip_entry_index(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_index(
      zip,
    );
  }

  late final _zip_entry_indexPtr =
      _lookup<ffi.NativeFunction<ssize_t Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_index');
  late final _zip_entry_index =
      _zip_entry_indexPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Determines if the current zip entry is a directory entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - 1 (true), 0 (false), negative number (< 0) on
  /// error.
  int zip_entry_isdir(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_isdir(
      zip,
    );
  }

  late final _zip_entry_isdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_isdir');
  late final _zip_entry_isdir =
      _zip_entry_isdirPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the uncompressed size of the current zip entry.
  /// Alias for zip_entry_uncomp_size (for backward compatibility).
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the uncompressed size in bytes.
  int zip_entry_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_size(
      zip,
    );
  }

  late final _zip_entry_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>('zip_entry_size');
  late final _zip_entry_size =
      _zip_entry_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the uncompressed size of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the uncompressed size in bytes.
  int zip_entry_uncomp_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_uncomp_size(
      zip,
    );
  }

  late final _zip_entry_uncomp_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_uncomp_size');
  late final _zip_entry_uncomp_size =
      _zip_entry_uncomp_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the compressed size of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the compressed size in bytes.
  int zip_entry_comp_size(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_comp_size(
      zip,
    );
  }

  late final _zip_entry_comp_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_comp_size');
  late final _zip_entry_comp_size =
      _zip_entry_comp_sizePtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns CRC-32 checksum of the current zip entry.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the CRC-32 checksum.
  int zip_entry_crc32(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_crc32(
      zip,
    );
  }

  late final _zip_entry_crc32Ptr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<zip_t>)>>(
          'zip_entry_crc32');
  late final _zip_entry_crc32 =
      _zip_entry_crc32Ptr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns byte offset of the current zip entry
  /// in the archive's central directory.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the offset in bytes.
  int zip_entry_dir_offset(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_dir_offset(
      zip,
    );
  }

  late final _zip_entry_dir_offsetPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_dir_offset');
  late final _zip_entry_dir_offset =
      _zip_entry_dir_offsetPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Returns the current zip entry's local header file offset in bytes.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the entry's local header file offset in bytes.
  int zip_entry_header_offset(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entry_header_offset(
      zip,
    );
  }

  late final _zip_entry_header_offsetPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedLongLong Function(ffi.Pointer<zip_t>)>>(
      'zip_entry_header_offset');
  late final _zip_entry_header_offset = _zip_entry_header_offsetPtr
      .asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Compresses an input buffer for the current zip entry.
  ///
  /// @param zip zip archive handler.
  /// @param buf input buffer.
  /// @param bufsize input buffer size (in bytes).
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_write(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Void> buf,
    int bufsize,
  ) {
    return _zip_entry_write(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('zip_entry_write');
  late final _zip_entry_write = _zip_entry_writePtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>, int)>();

  /// Compresses a file for the current zip entry.
  ///
  /// @param zip zip archive handler.
  /// @param filename input file.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_fwrite(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _zip_entry_fwrite(
      zip,
      filename,
    );
  }

  late final _zip_entry_fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_fwrite');
  late final _zip_entry_fwrite = _zip_entry_fwritePtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Extracts the current zip entry into output buffer.
  ///
  /// The function allocates sufficient memory for a output buffer.
  ///
  /// @param zip zip archive handler.
  /// @param buf output buffer.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @note remember to release memory allocated for a output buffer.
  /// for large entries, please take a look at zip_entry_extract function.
  ///
  /// @return the return code - the number of bytes actually read on success.
  /// Otherwise a negative number (< 0) on error.
  int zip_entry_read(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buf,
    ffi.Pointer<ffi.Size> bufsize,
  ) {
    return _zip_entry_read(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('zip_entry_read');
  late final _zip_entry_read = _zip_entry_readPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Size>)>();

  /// Extracts the current zip entry into a memory buffer using no memory
  /// allocation.
  ///
  /// @param zip zip archive handler.
  /// @param buf preallocated output buffer.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @note ensure supplied output buffer is large enough.
  /// zip_entry_size function (returns uncompressed size for the current
  /// entry) can be handy to estimate how big buffer is needed.
  /// For large entries, please take a look at zip_entry_extract function.
  ///
  /// @return the return code - the number of bytes actually read on success.
  /// Otherwise a negative number (< 0) on error (e.g. bufsize is not large
  /// enough).
  int zip_entry_noallocread(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Void> buf,
    int bufsize,
  ) {
    return _zip_entry_noallocread(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_entry_noallocreadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('zip_entry_noallocread');
  late final _zip_entry_noallocread = _zip_entry_noallocreadPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Void>, int)>();

  /// Extracts the current zip entry into output file.
  ///
  /// @param zip zip archive handler.
  /// @param filename output file.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_fread(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _zip_entry_fread(
      zip,
      filename,
    );
  }

  late final _zip_entry_freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>>('zip_entry_fread');
  late final _zip_entry_fread = _zip_entry_freadPtr
      .asFunction<int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Char>)>();

  /// Extracts the current zip entry using a callback function (on_extract).
  ///
  /// @param zip zip archive handler.
  /// @param on_extract callback function.
  /// @param arg opaque pointer (optional argument, which you can pass to the
  /// on_extract callback)
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_entry_extract(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Size Function(ffi.Pointer<ffi.Void> arg, ffi.Uint64 offset,
                    ffi.Pointer<ffi.Void> data, ffi.Size size)>>
        on_extract,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_entry_extract(
      zip,
      on_extract,
      arg,
    );
  }

  late final _zip_entry_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Size Function(
                          ffi.Pointer<ffi.Void> arg,
                          ffi.Uint64 offset,
                          ffi.Pointer<ffi.Void> data,
                          ffi.Size size)>>,
              ffi.Pointer<ffi.Void>)>>('zip_entry_extract');
  late final _zip_entry_extract = _zip_entry_extractPtr.asFunction<
      int Function(
          ffi.Pointer<zip_t>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Size Function(
                      ffi.Pointer<ffi.Void> arg,
                      ffi.Uint64 offset,
                      ffi.Pointer<ffi.Void> data,
                      ffi.Size size)>>,
          ffi.Pointer<ffi.Void>)>();

  /// Returns the number of all entries (files and directories) in the zip archive.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return the return code - the number of entries on success, negative number
  /// (< 0) on error.
  int zip_entries_total(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_entries_total(
      zip,
    );
  }

  late final _zip_entries_totalPtr =
      _lookup<ffi.NativeFunction<ssize_t Function(ffi.Pointer<zip_t>)>>(
          'zip_entries_total');
  late final _zip_entries_total =
      _zip_entries_totalPtr.asFunction<int Function(ffi.Pointer<zip_t>)>();

  /// Deletes zip archive entries.
  ///
  /// @param zip zip archive handler.
  /// @param entries array of zip archive entries to be deleted.
  /// @param len the number of entries to be deleted.
  /// @return the number of deleted entries, or negative number (< 0) on error.
  int zip_entries_delete(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entries,
    int len,
  ) {
    return _zip_entries_delete(
      zip,
      entries,
      len,
    );
  }

  late final _zip_entries_deletePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('zip_entries_delete');
  late final _zip_entries_delete = _zip_entries_deletePtr.asFunction<
      int Function(
          ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Deletes zip archive entries.
  ///
  /// @param zip zip archive handler.
  /// @param entries array of zip archive entries indices to be deleted.
  /// @param len the number of entries to be deleted.
  /// @return the number of deleted entries, or negative number (< 0) on error.
  int zip_entries_deletebyindex(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Size> entries,
    int len,
  ) {
    return _zip_entries_deletebyindex(
      zip,
      entries,
      len,
    );
  }

  late final _zip_entries_deletebyindexPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Size>,
              ffi.Size)>>('zip_entries_deletebyindex');
  late final _zip_entries_deletebyindex =
      _zip_entries_deletebyindexPtr.asFunction<
          int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Size>, int)>();

  /// Extracts a zip archive stream into directory.
  ///
  /// If on_extract is not NULL, the callback will be called after
  /// successfully extracted each zip entry.
  /// Returning a negative value from the callback will cause abort and return an
  /// error. The last argument (void *arg) is optional, which you can use to pass
  /// data to the on_extract callback.
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.
  /// @param dir output directory.
  /// @param on_extract on extract callback.
  /// @param arg opaque pointer.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_stream_extract(
    ffi.Pointer<ffi.Char> stream,
    int size,
    ffi.Pointer<ffi.Char> dir,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Char> filename, ffi.Pointer<ffi.Void> arg)>>
        on_extract,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_stream_extract(
      stream,
      size,
      dir,
      on_extract,
      arg,
    );
  }

  late final _zip_stream_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                          ffi.Pointer<ffi.Void> arg)>>,
              ffi.Pointer<ffi.Void>)>>('zip_stream_extract');
  late final _zip_stream_extract = _zip_stream_extractPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                      ffi.Pointer<ffi.Void> arg)>>,
          ffi.Pointer<ffi.Void>)>();

  /// Opens zip archive stream into memory.
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_stream_open(
    ffi.Pointer<ffi.Char> stream,
    int size,
    int level,
    int mode,
  ) {
    return _zip_stream_open(
      stream,
      size,
      level,
      mode,
    );
  }

  late final _zip_stream_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Char)>>('zip_stream_open');
  late final _zip_stream_open = _zip_stream_openPtr.asFunction<
      ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Opens zip archive stream into memory.
  /// The function additionally returns @param errnum -
  ///
  /// @param stream zip archive stream.
  /// @param size stream size.*
  /// @param level compression level (0-9 are the standard zlib-style levels).
  /// @param mode file access mode.
  /// - 'r': opens a file for reading/extracting (the file must exists).
  /// - 'w': creates an empty file for writing.
  /// - 'a': appends to an existing archive.
  /// @param errnum 0 on success, negative number (< 0) on error.
  ///
  /// @return the zip archive handler or NULL on error
  ffi.Pointer<zip_t> zip_stream_openwitherror(
    ffi.Pointer<ffi.Char> stream,
    int size,
    int level,
    int mode,
    ffi.Pointer<ffi.Int> errnum,
  ) {
    return _zip_stream_openwitherror(
      stream,
      size,
      level,
      mode,
      errnum,
    );
  }

  late final _zip_stream_openwitherrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zip_t> Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Char, ffi.Pointer<ffi.Int>)>>('zip_stream_openwitherror');
  late final _zip_stream_openwitherror =
      _zip_stream_openwitherrorPtr.asFunction<
          ffi.Pointer<zip_t> Function(
              ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Int>)>();

  /// Copy zip archive stream output buffer.
  ///
  /// @param zip zip archive handler.
  /// @param buf output buffer. User should free buf.
  /// @param bufsize output buffer size (in bytes).
  ///
  /// @return copy size
  int zip_stream_copy(
    ffi.Pointer<zip_t> zip,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buf,
    ffi.Pointer<ffi.Size> bufsize,
  ) {
    return _zip_stream_copy(
      zip,
      buf,
      bufsize,
    );
  }

  late final _zip_stream_copyPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<zip_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('zip_stream_copy');
  late final _zip_stream_copy = _zip_stream_copyPtr.asFunction<
      int Function(ffi.Pointer<zip_t>, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Size>)>();

  /// Close zip archive releases resources.
  ///
  /// @param zip zip archive handler.
  ///
  /// @return
  void zip_stream_close(
    ffi.Pointer<zip_t> zip,
  ) {
    return _zip_stream_close(
      zip,
    );
  }

  late final _zip_stream_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<zip_t>)>>(
          'zip_stream_close');
  late final _zip_stream_close =
      _zip_stream_closePtr.asFunction<void Function(ffi.Pointer<zip_t>)>();

  /// Creates a new archive and puts files into a single zip archive.
  ///
  /// @param zipname zip archive file.
  /// @param filenames input files.
  /// @param len: number of input files.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_create(
    ffi.Pointer<ffi.Char> zipname,
    ffi.Pointer<ffi.Pointer<ffi.Char>> filenames,
    int len,
  ) {
    return _zip_create(
      zipname,
      filenames,
      len,
    );
  }

  late final _zip_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Size)>>('zip_create');
  late final _zip_create = _zip_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Extracts a zip archive file into directory.
  ///
  /// If on_extract_entry is not NULL, the callback will be called after
  /// successfully extracted each zip entry.
  /// Returning a negative value from the callback will cause abort and return an
  /// error. The last argument (void *arg) is optional, which you can use to pass
  /// data to the on_extract_entry callback.
  ///
  /// @param zipname zip archive file.
  /// @param dir output directory.
  /// @param on_extract_entry on extract callback.
  /// @param arg opaque pointer.
  ///
  /// @return the return code - 0 on success, negative number (< 0) on error.
  int zip_extract(
    ffi.Pointer<ffi.Char> zipname,
    ffi.Pointer<ffi.Char> dir,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Char> filename, ffi.Pointer<ffi.Void> arg)>>
        on_extract_entry,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _zip_extract(
      zipname,
      dir,
      on_extract_entry,
      arg,
    );
  }

  late final _zip_extractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                          ffi.Pointer<ffi.Void> arg)>>,
              ffi.Pointer<ffi.Void>)>>('zip_extract');
  late final _zip_extract = _zip_extractPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Char> filename,
                      ffi.Pointer<ffi.Void> arg)>>,
          ffi.Pointer<ffi.Void>)>();
}

/// @struct zip_t
///
/// This data structure is used throughout the library to represent zip archive -
/// forward declaration.
final class zip_t extends ffi.Opaque {}

typedef ssize_t = ffi.LongLong;
typedef Dartssize_t = int;

const int ZIP_DEFAULT_COMPRESSION_LEVEL = 6;

const int ZIP_ENOINIT = -1;

const int ZIP_EINVENTNAME = -2;

const int ZIP_ENOENT = -3;

const int ZIP_EINVMODE = -4;

const int ZIP_EINVLVL = -5;

const int ZIP_ENOSUP64 = -6;

const int ZIP_EMEMSET = -7;

const int ZIP_EWRTENT = -8;

const int ZIP_ETDEFLINIT = -9;

const int ZIP_EINVIDX = -10;

const int ZIP_ENOHDR = -11;

const int ZIP_ETDEFLBUF = -12;

const int ZIP_ECRTHDR = -13;

const int ZIP_EWRTHDR = -14;

const int ZIP_EWRTDIR = -15;

const int ZIP_EOPNFILE = -16;

const int ZIP_EINVENTTYPE = -17;

const int ZIP_EMEMNOALLOC = -18;

const int ZIP_ENOFILE = -19;

const int ZIP_ENOPERM = -20;

const int ZIP_EOOMEM = -21;

const int ZIP_EINVZIPNAME = -22;

const int ZIP_EMKDIR = -23;

const int ZIP_ESYMLINK = -24;

const int ZIP_ECLSZIP = -25;

const int ZIP_ECAPSIZE = -26;

const int ZIP_EFSEEK = -27;

const int ZIP_EFREAD = -28;

const int ZIP_EFWRITE = -29;

const int ZIP_ERINIT = -30;

const int ZIP_EWINIT = -31;

const int ZIP_EWRINIT = -32;
